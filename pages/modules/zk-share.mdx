# ZKShare Module (DKMS)
ZK-MPC encrypted secret sharing module enabling the most private decentralized file sharing with no one in the middle, not event idSign; ONLY the wallets added to document can ever reconstruct and decrypt the documents shared via IPFS

---

**Objective**: Securely share a secret among a predefined set of users/wallets, authorized via their wallet addresses, using zero-knowledge proofs to maintain privacy.

**Components**:

- **Smart Contract or Decentralized Storage:** For Storing The resourceID, encryptedSecret, and its ACLs (Access Control Lists). These values can be stored publicly leveraging the “no single point of failure” nature of this technology but at the same time ensuring privacy of the stored secret limiting it to a set of authorized users
- **zkShare module:** For generating a new share, granting access of a share and modifying ACLs of an existing share. This should be implemented through programmable MPC actions leveraging computational rules done by multiple on-chain nodes (zkSmartContract)

**Use Cases:**

- End-to-end Encrypted on-chain messaging
- Decentralized file-sharing (sharing the decryption key of an encrypted file stored on IPFS)
- Sharing information privately between DAO members
- Token-Gating without relying on a server to “Gate” the resource or the key to the resource
- Many more…

**Implementation Flow:**

- User1 wants to share data `D` with User2 and User3 `ACLs`
- On Frontend, Generate a unique hash `D-H` from the data we want to encrypt and a hash `ACL-H` from the ACLs
- Call `ZKshare.set(D-H+ACL-H)`  this function will:
    1. Do a Blockchain call: This will create a new multi-party wallet bound only to this new share and have role-based signatures authorizing only User1, User2 and User3 to request signatures. Unlike multi-sig wallet, this multi-party wallet allows one user to generate signatures based on if he is included in the `ACLs`  and also based on if they satisfy the rules defined in the ACLs (such as being a DAO member, or holds an NFT, or just have a valid signature)
    2. Blockchain Response: This new share-bound wallet will request the MPC nodes to generate a TSS signature `S`. Each node will return part of the signature to the frontend
    3. The frontend combines the signature parts into one signature and encrypts `D` with that signature. (The signature will be the encryption/decryption key)
    4. Finally the function will return `encryptedData`
- User1 now can safely store `ACLs, encryptedData and D-H` publicly on a smart contract or IPFS or database

- User2 now wants to access the file. They are logged in with any EOA
- User2 queries the API or smart contract that returns the `ACLs, encryptedData and D-H` of the resources he is part of.
- User2 calls `ZKshare.get(D-H, ACLs, personal_sign)` this function will:
    - request a TSS signature from the same share-bound wallet created by user1
    - Before creating the signature, the blockchain node must verify that this user is in the ACLs and satisfies the rules set by these ACLs
    - If this is true, then the MPC nodes creates the same signature and sends back the parts to user2
- User2 can combine the signature parts and decrypt `encryptedData` to get the original data `D`

The programmable MPC wallet should have 1/n of a signature extracting the public key and checking it to the ACLs and then hash the ACLs to compare with ACL-H

**Example Implementation:**

```rust
// This is a sample and should not be used in production!!
// TODO:
//  - The function split_aes_key should contain real cryptographic splitting logic.
//  - sign_vault_id must utilize cryptographic methods to sign the vault's ID securely.
//  - Authentication mechanisms and SIWE integration must be implemented according to Ethereum standards.
//  - Salt retrieval and session management should be securely handled to prevent MITM attacks and replay attacks.
//  - The frontend will need to interact with these functions using a web3 interface, sending public/private keys and session management securely.
extern crate pbc_contract_codegen;
extern crate pbc_contract_common;

use pbc_contract_common::context::ContractContext;
use pbc_contract_common::zk::{ZkInputDef, ZkState};
use pbc_contract_common::crypto::secp256k1::Secp256k1;
use pbc_contract_common::crypto::aes::{Aes256, NewCipher, generic_array::GenericArray};
use std::collections::HashMap;
use pbc_zk::{Sbi64, PublicKey, SecretBinary};
use serde::{Serialize, Deserialize};

/// Structure for storing encrypted secrets and the list of authorized addresses
#[derive(Serialize, Deserialize)]
pub struct Vault {
    owner: PublicKey,
    secret_part_1: Sbi64,
    secret_part_2: Sbi64,
    secret_part_3: Sbi64,
    members: Vec<PublicKey>,
}

#[state]
struct ContractState {
    vaults: HashMap<u32, Vault>,
}

/// Initialize the contract state
#[init]
fn initialize(ctx: ContractContext) -> ContractState {
    ContractState {
      vaults: HashMap::new(),
    }
}

#[zk_on_secret_input]
pub fn set(unique_id: i32, members: Vec<PublicKey>) -> String {
    // Simulate splitting AES key into three parts
    let aes_key_parts = split_aes_key(); 
    let vault = Vault {
        owner: get_public_key(), // Assuming function to fetch owner's public key
        secret_part_1: aes_key_parts.0,
        secret_part_2: aes_key_parts.1,
        secret_part_3: aes_key_parts.2,
        members,
    };

    // Simulate signing the vault ID with the private secret
    let signature = sign_vault_id(unique_id, &vault);
    signature
}

#[zk_on_compute_complete]
pub fn get(vault_id: i32, siwe_signature: String) -> Result<Sbi64, &'static str> {
    let address = verify_siwe_signature(siwe_signature)?;
    let salt = request_salt_from_server(address)?;

    let vault = load_vault(vault_id);
    if vault.members.contains(&address) {
        let combined_aes_key = combine_secret_parts(vault.secret_part_1, vault.secret_part_2, vault.secret_part_3);
        Ok(combined_aes_key)
    } else {
        Err("Access Denied")
    }
}

fn split_aes_key() -> (Sbi64, Sbi64, Sbi64) {
    // Placeholder: logic to split AES key into three parts
    (Sbi64::from(123), Sbi64::from(456), Sbi64::from(789))
}

fn sign_vault_id(vault_id: i32, vault: &Vault) -> String {
    // Placeholder: logic to generate a signature
    "signature_placeholder".to_string()
}

fn verify_siwe_signature(signature: String) -> Result<PublicKey, &'static str> {
    // Placeholder: logic to verify SIWE signature
    Ok(PublicKey::new())
}

fn request_salt_from_server(wallet_address: PublicKey) -> Result<i64, &'static str> {
    // Placeholder: logic to request salt
    Ok(123456)
}

fn combine_secret_parts(part1: Sbi64, part2: Sbi64, part3: Sbi64) -> Sbi64 {
    part1 + part2 + part3 // Simplified, should be SSS
}

fn load_vault(vault_id: i32) -> Vault {
    // Placeholder: logic to load vault
    return state.vaults[vault_id]
}

```

**Example Usage:**

> [idSign.com](http://idSign.com) is a decentralized eSignature protocol that allows users to sign agreements(pdfs) on-chain and get a SoulBound NFT (proof-of-signature). Anyone can verify that the parties signed an agreement but ONLY the parties can access the pdf agreement shared for signature. No one in the middle, mot even idSign, can ever decrypt the document. The parties can choose the add/remove mediators or lawyers to their agreement 

**NB:** idSign is a DAPP, not a wallet, nor blockchain and does not have access to a user’s private key
> 

1. Document/Agreement creation: 
    1. User1 uploads a pdf, sets the parties’s wallets that should sign
    2. The frontend encrypts the pdf file and stores the encrypted file on IPFS
    3. The encryptionKey (generated on the frontend by AES) should be shared by the parties
    
    ```jsx
    const provider = '<Any wallet provider>'
    const idSignSmartContract = '<our smart contract>'

    const agreement = {
    	name: String,
    	file: BASE64,
    	parties: [] 0x111
    }
    
    const Key = '<generate AES symm key>'
    const encFile = AES.encrypt(agreement.file, Key)
    const acls = isArrayBindingElement.parties

    const mpcSignature = zkShare.set(Hash(Key), Hash(acls))
    const encKey = AES.encrypt(Key, mpcSignature)

    
    const ipfsCid = await uploadIPFS(encFile)
    
    const res = await idSignSmartContract.mint(
    								agreement.name,
    								agreement.parties,
    								ipfsCid,
    								encKey,
                                    Hash(Key)
                        ) // this mints ProofOfSignature soul-bound NFT on any EVM chain
    ```
    

2. Document/Agreement access & sign: 
    1. User2 scans our smart contract for RFSs (Request-For-Signature NFTs)
    2. The frontend downloads the encrypted pdf file from IPFS
    3. User 2 requests zkShare for the decryption key
    4. User2 can now decrypt and read the contents of the pdf and signs it
    
    ```jsx
    const provider = '<Any wallet provider>'
    const idSignSmartContract = '<our smart contract>'

    const NFT = {
    	id: Number,
    	name: String,
    	parties: [] 0x111,
    	ipfsCid: String,
    	encKey: String,
        keyHash: String
    }
    
    const personalSig = provider.signMessage(session)
    const mpcSignature = zkShare.get(NFT.keyHash, NodeFilter.parties, authSignature)
    const Key = AES.decrypt(NodeFilter.encKey, mpcSignature)
    
    const encFile = await downloadIPFS(NFT.ipfsCid)
    const file = AES.decrypt(encFile, Key)
    
    const signature = provider.signMessage(
    					"I agree to the agreement "+NFT.id + "Date"+Date.now()
    			)
    
    const res = await idSignSmartContract.sign(NFT.id, signature) // this will record the signature on the NFT in an EVM chain
    
    ```
