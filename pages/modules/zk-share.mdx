# ZKShare Module (DKMS)
ZK-MPC encrypted secret sharing module enabling the most private decentralized file sharing with no one in the middle, not event idSign; ONLY the wallets added to document can ever reconstruct and decrypt the documents shared via IPFS

---

**Objective**: Securely share a secret among a predefined set of users/wallets, authorized via their wallet addresses, using zero-knowledge proofs to maintain privacy.

**Components**:

- **Smart Contract or Decentralized Storage:** For Storing The resourceID, encryptedSecret, and its ACLs (Access Control Lists). These values can be stored publicly leveraging the “no single point of failure” nature of this technology but at the same time ensuring privacy of the stored secret limiting it to a set of authorized users
- **zkShare module:** For generating a new share, granting access of a share and modifying ACLs of an existing share. This should be implemented through programmable MPC actions leveraging computational rules done by multiple on-chain nodes (zkSmartContract)

**Use Cases:**

- End-to-end Encrypted on-chain messaging
- Decentralized file-sharing (sharing the decryption key of an encrypted file stored on IPFS)
- Sharing information privately between DAO members
- Token-Gating without relying on a server to “Gate” the resource or the key to the resource
- Many more…

**Implementation Flow:**

- User1 wants to share a password `P` with User2 and User3 which are the simple `ACLs`
- On Frontend, Generate a unique hash `UID` for this new share. This UID can be a one-way hash of (P + ACLs + UUID)
- Call `zkShare.set(UID, ACLs, P)`  this function will:
    1. Do a Blockchain call: This will create a new multi-party wallet bound only to this new share and have role-based signatures authorizing only User1, User2 and User3 to request signatures. Unlike multi-sig wallet, this multi-party wallet allows one user to generate signatures based on if he is included in the `ACLs`  and also based on if they satisfy the rules defined in the ACLs (such as being a DAO member, or holds an NFT, or just have a valid signature)
    2. Blockchain Response: This new share-bound wallet will request the MPC nodes to generate a TSS signature `S`  with data `UID`. Each node will return part of the signature to the frontend
    3. Using SSS or and other algorithm, the frontend combines the signature parts into one signature and encrypts `P` with that signature. (The signature will be the encryption/decryption key)
    4. Finally the function will return `encryptedSecret`
- User1 now can safely store `UID, encryptedSecret and ACLs` publicly on a smart contract or IPFS or database API

- User2 now wants to access the file. They are logged in with any EOA
- User2 queries the API or smart contract that returns the `UID, encryptedSecret and ACLs` of the resources he is part of queried from the ACLs
- User2 calls `zkShare.get(UID, sig)` the sig data can be a unique session generated by `zkShare.init()`
    - this function will request a TSS signature with data UID from the same share-bound wallet created by user1
    - Before creating the signature, the blockchain node must verify that this user is in the ACLs and satisfies the rules set by these ACLs
    - If this is true, then the MPC nodes creates the same signature and sends back the parts to user2
- User2 can combine the signature parts and decrypt `encryptedSecret` to get the original secret `S`
- If The ACLs allows User2 to also modify the share, they can now also update the ACLs of that share.

**Example Usage:**

> [idSign.com](http://idSign.com) is a decentralized eSignature protocol that allows users to sign agreements(pdfs) on-chain and get a SoulBound NFT (proof-of-signature). Anyone can verify that the parties signed an agreement but ONLY the parties can access the pdf agreement shared for signature. No one in the middle, mot even idSign, can ever decrypt the document. The parties can choose the add/remove mediators or lawyers to their agreement 

**NB:** idSign is a DAPP, not a wallet, nor blockchain and does not have access to a user’s private key
> 

1. Document/Agreement creation: 
    1. User1 uploads a pdf, sets the parties’s wallets that should sign
    2. The frontend encrypts the pdf file and stores the encrypted file on IPFS
    3. The encryptionKey (generated on the frontend by AES) should be shared by the parties
    
    ```jsx
    const agreement = {
    	name:String
    	file:BASE64,
    	parties: [0x1111, 0x2222]
    }
    
    const provider = [Any wallet provider]
    const idSignSmartContract = [our smart contract]
    
    const symmKey = [generate AES symm key]
    const encFile = AES.encrypt(agreement.file, symmKey)
    const ipfsCid = await uploadIPFS(encFile)
    
    const acls = [
    	{adrr: provider.address, role: "ADMIN", rules:["WALLET-SIG"]},
    	{adrr: agreement.parties[0], role: "VIEW", rules:["WALLET-SIG"]},
    	{adrr: agreement.parties[1], role: "VIEW", rules:["WALLET-SIG"]},
    ]
    
    const encSymmKey = zkShare.set(ipfsCid, acls, symmKey)
    
    const res = await idSignSmartContract.mint(
    								agreement.name,
    								agreement.parties,
    								ipfsCid,
    								encSymmKey) // this mints RequestForSignature for wallets
    ```
    

2. Document/Agreement access & sign: 
    1. User2 scans our smart contract for RFSs (Request-For-Signature NFTs)
    2. The frontend downloads the encrypted pdf file from IPFS
    3. User 2 requests zkShare for the decryption key
    4. User2 can now decrypt and read the contents of the pdf and signs it
    
    ```jsx
    const RFSnft = {
    	nftID:Number,
    	name:String,
    	parties: [0x1111, 0x2222],
    	ipfsCid:String,
    	encSymmKey:String
    }
    const encFile = await downloadIPFS(RFSnft.ipfsCid)
    
    const provider = [Any wallet provider]
    const idSignSmartContract = [our smart contract]
    
    const session = zkShare.init()
    const authSignature = provider.signMessage(session)
    const mpcSignature = zkShare.get(RFSnft.ipfsCid, authSignature)
    
    const symmKey = AES.decrypt(RFSnft.encSymmKey, mpcSignature)
    const file = AES.decrypt(encFile, symmKey)
    
    const signature = provider.signMessage(
    					"I agree to the agreement "+RFSnft.ipfsCid + "Date"+Date.now()
    			)
    
    const res = await idSignSmartContract.sign(RFSnft.nftID, signature)
    
    ```
    

We also have other use-cases where user can share other files such as DID documents with third-party-providers such as passport copy pdf